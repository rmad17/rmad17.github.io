<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rise and Rise of Rust | Svādhyāya</title>
<meta name=keywords content><meta name=description content="The Quiet Beginning and the First Ripples In 2010, a Mozilla researcher named Graydon Hoare began working on a personal project born from frustration—a stuck elevator had triggered a software failure that could have been prevented with better memory management. This moment of annoyance would eventually give birth to Rust, a language that would fundamentally challenge how we think about systems programming.
For its first few years, Rust remained largely within Mozilla&rsquo;s walls, quietly evolving through rapid iterations."><meta name=author content><link rel=canonical href=http://localhost:1313/posts/rise-and-rise-of-rust/><meta name=google-site-verification content="G-Z8CH2E9HK0"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/icon-1.png><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/icon-1.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/icon-1.png><link rel=apple-touch-icon href=http://localhost:1313/icon-1.png><link rel=mask-icon href=http://localhost:1313/icon-1.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/rise-and-rise-of-rust/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-Z8CH2E9HK0"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Z8CH2E9HK0",{anonymize_ip:!1})}</script><meta property="og:title" content="Rise and Rise of Rust"><meta property="og:description" content="The Quiet Beginning and the First Ripples In 2010, a Mozilla researcher named Graydon Hoare began working on a personal project born from frustration—a stuck elevator had triggered a software failure that could have been prevented with better memory management. This moment of annoyance would eventually give birth to Rust, a language that would fundamentally challenge how we think about systems programming.
For its first few years, Rust remained largely within Mozilla&rsquo;s walls, quietly evolving through rapid iterations."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/rise-and-rise-of-rust/"><meta property="og:image" content="http://localhost:1313/riseofrust.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-18T12:53:54+05:30"><meta property="article:modified_time" content="2025-09-18T12:53:54+05:30"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/riseofrust.png"><meta name=twitter:title content="Rise and Rise of Rust"><meta name=twitter:description content="The Quiet Beginning and the First Ripples In 2010, a Mozilla researcher named Graydon Hoare began working on a personal project born from frustration—a stuck elevator had triggered a software failure that could have been prevented with better memory management. This moment of annoyance would eventually give birth to Rust, a language that would fundamentally challenge how we think about systems programming.
For its first few years, Rust remained largely within Mozilla&rsquo;s walls, quietly evolving through rapid iterations."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Rise and Rise of Rust","item":"http://localhost:1313/posts/rise-and-rise-of-rust/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rise and Rise of Rust","name":"Rise and Rise of Rust","description":"The Quiet Beginning and the First Ripples In 2010, a Mozilla researcher named Graydon Hoare began working on a personal project born from frustration—a stuck elevator had triggered a software failure that could have been prevented with better memory management. This moment of annoyance would eventually give birth to Rust, a language that would fundamentally challenge how we think about systems programming.\nFor its first few years, Rust remained largely within Mozilla\u0026rsquo;s walls, quietly evolving through rapid iterations.","keywords":[],"articleBody":"The Quiet Beginning and the First Ripples In 2010, a Mozilla researcher named Graydon Hoare began working on a personal project born from frustration—a stuck elevator had triggered a software failure that could have been prevented with better memory management. This moment of annoyance would eventually give birth to Rust, a language that would fundamentally challenge how we think about systems programming.\nFor its first few years, Rust remained largely within Mozilla’s walls, quietly evolving through rapid iterations. The language reached its 1.0 stable release in May 2015, marking the beginning of its public journey. But it wasn’t until 2017-2018 that the first significant impacts began to show. Firefox’s Quantum release in 2017, which incorporated Rust components for CSS parsing and rendering, demonstrated that Rust could deliver on its promises at scale—offering both memory safety and performance that matched or exceeded C++.\nThe early adopters were pioneers willing to bet on an unproven technology. Dropbox began experimenting with Rust for their file synchronization engine around 2016, while Discord started evaluating it for performance-critical services. These early experiments would soon turn into production success stories that would inspire an entire industry.\nThe Enterprise Awakening: When Giants Started Moving By 2019-2020, something remarkable was happening. Major technology companies weren’t just experimenting with Rust—they were making strategic commitments to it. Microsoft made headlines when they announced that they were exploring Rust for systems programming in Windows, citing that 70% of their security vulnerabilities were memory safety issues that Rust could eliminate by design.\nCompanies like Microsoft, Amazon, Dropbox, Discord, and Cloudflare began migrating critical infrastructure to Rust. The community was growing exponentially, with contributions pouring in from developers worldwide. The Rust Foundation was established in 2021 with founding members including AWS, Google, Microsoft, Mozilla, and Huawei—a clear signal that Rust had graduated from interesting experiment to strategic technology.\nDiscord’s migration story became legendary in engineering circles. Their “Read States” service, which tracks which channels and messages users have read and is accessed every time you connect to Discord, every time a message is sent and every time a message is read, was suffering from Go’s garbage collection pauses. After switching to Rust, latency, CPU, and memory were all better in the Rust version, with average response times measured in microseconds rather than milliseconds.\nThe Linux kernel, the holy grail of systems programming, accepted Rust as its second official language in 2022—a decision that sent shockwaves through the industry. For decades, the kernel had been written entirely in C. This acceptance wasn’t just symbolic; it was practical recognition that Rust’s safety guarantees could prevent entire classes of vulnerabilities in the world’s most critical software infrastructure.\nThe Present Age: Rust Everywhere Fast forward to 2025, and Rust’s adoption has reached a tipping point. According to JetBrains’ State of Developer Ecosystem Survey in 2024, an estimated 2,267,000 developers used Rust in a span of 12 months, with 709,000 identifying Rust as their primary language. This isn’t just growth—it’s an explosion.\nFor the ninth year in a row, the 2024 Stack Overflow Developer Survey named Rust the language that developers admired most, with an 83% admiration rate. But beyond developer satisfaction, the real story is in production deployment. Commercial Rust usage exploded by 68.75% between 2021-2024, with tech giants not just using Rust, but betting their future on it.\nSince adopting Rust for Android, Google has cut memory vulnerabilities from 223 in 2019 to under 50 in 2024—a 68% drop. Amazon’s Firecracker, the microVM technology behind AWS Lambda, is written entirely in Rust, handling millions of serverless function invocations. Meta added Rust as an officially supported server-side language alongside C++ and Python.\nThe open source ecosystem has flourished beyond anyone’s expectations. Cargo, Rust’s package manager, hosts over 150,000 crates (packages), covering everything from web frameworks to machine learning libraries. Tools that developers rely on daily are increasingly being rewritten in Rust—from JavaScript bundlers like SWC and Turbopack to terminal emulators like Alacritty and Warp.\nWebAssembly: Rust’s Killer App Perhaps no technology has done more to accelerate Rust adoption than WebAssembly (WASM). Rust has become a first-class language for WebAssembly, enabling high-performance, sandboxed code to run in the browser. Based on comprehensive benchmarks, Rust outperforms C++ in most WebAssembly 3.0 scenarios in 2025, showing 15-20% better performance in numerical computations and 30% faster DOM manipulation.\nCompanies are ditching Docker containers in favor of Wasm modules compiled from Rust, finding them to be faster, lighter, and more secure. The startup time for a WASM module is measured in microseconds compared to seconds for containers, and the memory footprint is a fraction of traditional containerized applications.\nBevy: The Game Engine Revolution In the game development world, Bevy has emerged as Rust’s flagship game engine, challenging the dominance of Unity and Unreal. With its Entity Component System (ECS) architecture that scales to millions of entities with zero overhead, Bevy is attracting indie developers and AAA studios alike. The engine’s ability to compile to both native code and WebAssembly means games can run at full performance in browsers without plugins—a dream that’s finally becoming reality.\nThe Secret Sauce: Why Rust Succeeds Where Others Failed Memory Safety Without Compromise Rust’s ownership system is revolutionary because it achieves memory safety without garbage collection. The system provides more predictable performance characteristics as there are no pauses for garbage collection. This isn’t just about preventing crashes—it’s about eliminating entire categories of security vulnerabilities at compile time.\nMicrosoft’s Security Report shows that Rust eliminates 70% of memory-related bugs, which traditionally account for the majority of critical security vulnerabilities. When you compile a Rust program successfully, you have mathematical guarantees about memory safety that no amount of testing in C++ could provide.\nPerformance That Matches C++ Benchmarks consistently show Rust matching or exceeding C++ performance. Rust’s performance cannot be overstated. Benchmarks consistently show Rust matching or surpassing C and C++ in execution speed, while still offering concurrency support that avoids common pitfalls. The zero-cost abstractions mean you can write high-level, expressive code that compiles down to the same machine code as hand-optimized C.\nDeveloper Experience That Doesn’t Suck Unlike C++, which has accumulated decades of complexity and gotchas, Rust was designed from the ground up with developer experience in mind. Cargo handles dependencies, building, testing, and documentation generation. The compiler’s error messages are so helpful they’ve become legendary—often suggesting exact fixes for problems. The standard library is comprehensive and modern, and the documentation is exceptional.\nFearless Concurrency Rust’s relatively unique memory management approach incorporates the idea of memory “ownership”. It knows when the program is using memory and immediately frees the memory once it is no longer needed. This ownership system makes data races impossible at compile time. You can write concurrent code with confidence, knowing that if it compiles, it’s free from data races.\nAdopting Rust: Lessons from the Trenches Discord’s Playbook: Incremental Migration Discord’s approach to Rust adoption has become a template for others. They started by rewriting a single service—the Read States service—which was experiencing performance issues with Go’s garbage collector. The results were so impressive that they’ve continued migrating services to Rust, including their database migration tooling, where they wrote it from scratch in Rust because using existing tools would have taken 3 months, but with Rust and the Tokio async ecosystem, migration was completed in just 9 days.\nDropbox’s Testament: Betting Big and Winning Dropbox rewrote their sync engine, codenamed “Nucleus,” entirely in Rust. They stated that “Rust has been a force multiplier for our team, and betting on Rust was one of the best decisions we made”. The new engine handles billions of files and trillions of synchronizations with improved performance and reliability.\nMicrosoft’s Strategy: Gradual System Integration Microsoft has been methodically introducing Rust into Windows components, Azure infrastructure, and developer tools. They’re not doing a wholesale rewrite but strategically replacing components where memory safety is critical. This measured approach has allowed them to gain experience and build internal expertise while managing risk.\nAmazon’s Cloud Revolution AWS has gone all-in on Rust for new services. Beyond Firecracker, they’re using Rust for Bottlerocket (their container OS), parts of S3, and various internal tools. AWS cites performance, security, and resource efficiency as key reasons for choosing Rust over C++.\nThe Challenges: Let’s Be Honest The Learning Curve Is Real Learning curve: 5-6 months to proficiency, steepest in first 1-2 months. The ownership system, lifetimes, and borrow checker require a fundamentally different way of thinking about code. One of the main challenges of learning Rust is grappling with its borrow checker—a mechanism that ensures references do not outlive the data they refer to.\nCompanies report that onboarding engineers to Rust typically takes 3-6 months, compared to weeks for languages like Go or Python. However, once over the hump, developers report higher productivity and confidence in their code.\nCompilation Times Rust’s comprehensive compile-time checks come at a cost. Large projects can take several minutes to compile from scratch, though incremental compilation has improved significantly. Teams often need to invest in better CI/CD infrastructure and adopt strategies like compilation caching.\nEcosystem Gaps While Rust’s ecosystem is growing rapidly, it still lacks the maturity of languages like Java or Python in certain domains. GUI frameworks are still evolving, and some specialized libraries common in other languages don’t yet have Rust equivalents.\nTalent Scarcity Rust developers command salary premiums of 15-20% over comparable roles in other languages. The demand far exceeds supply, making it challenging and expensive to build Rust teams quickly.\nValidation Through Real-World Use Cases Where Rust Shines Brightest Systems Programming: Major tech companies like Microsoft, Google, Amazon, and Meta are increasingly using Rust for critical systems components. This includes operating system development (with Rust now in the Linux kernel), browser development, and low-level Windows components.\nCloud Infrastructure: Cloudflare has rewritten significant portions of their edge computing platform in Rust, handling millions of requests per second with improved reliability and lower resource consumption.\nBlockchain: Solana, Polkadot, and NEAR Protocol are all built primarily in Rust. The combination of performance, safety, and deterministic execution makes Rust ideal for blockchain implementations.\nEmbedded Systems: There’s a slight uptick in users targeting embedded platforms, where Rust’s safety and performance are highly valued. The ability to write safe code without a runtime or garbage collector is perfect for resource-constrained environments.\nWeb Services: Companies like 1Password, Figma, and npm have significant Rust components in their backend services, citing improved performance and reduced operational costs.\nWhen to Choose Rust Choose Rust when:\nMemory safety and security are critical Performance requirements approach hardware limits You’re building infrastructure that will run for years Concurrent processing is a core requirement You need predictable latency (no GC pauses) The cost of bugs is high (financial systems, medical devices) Consider alternatives when:\nRapid prototyping is more important than performance You need to hire many developers quickly The existing ecosystem in another language is critical The application is primarily I/O bound rather than CPU bound The Future: Where Rust Goes from Here The 2026-2030 Trajectory As we approach 2026, we can expect Rust to further penetrate industries that rely on performance, security, and reliability—like finance, automotive, aerospace, and healthcare. Several trends are converging to accelerate Rust adoption:\nAI and Machine Learning: While Python dominates AI research, Rust is becoming the language of choice for production inference engines. Teams prototype in Python, then deploy with Rust. Libraries like Candle and Burn are making Rust-native ML more accessible.\nEdge Computing: As computing moves to the edge, Rust’s small binaries and predictable performance become even more valuable. The combination of Rust and WebAssembly is enabling new architectures where code can run anywhere from cloud to browser to IoT devices.\nAutomotive and Aerospace: Industries with strict safety requirements are embracing Rust. Several automotive companies are using Rust for next-generation vehicle software, where failures could be catastrophic.\nFinancial Services: High-frequency trading firms and cryptocurrency platforms are increasingly turning to Rust for its combination of performance and correctness guarantees.\nThe Ecosystem Evolution The Rust ecosystem is approaching an inflection point. With the async ecosystem maturing, GUI frameworks stabilizing, and tooling improving, many of the historical barriers to adoption are falling away.\nWASM is a game changer and the merging of Rust and WASM will be seamless. Developers will now be able to create web applications that are high performance and directly run on browsers, pushing the limits of web development.\nGame development in Rust is accelerating, with engines like Bevy gaining traction and major studios beginning to adopt Rust for performance-critical components. The ability to share code between server and client through WASM is opening new architectural possibilities.\nThe Language Evolution The Rust team’s focus has shifted from adding features to improving ergonomics and reducing friction. 2025 Focus: Rust’s H1 2025 efforts prioritized stabilizing compiler flags and tooling rather than launching new language features—a maturity-oriented shift that enterprises wanted to see.\nFuture improvements will focus on:\nReducing compilation times through better incremental compilation Improving the async experience with better syntax and error messages Making the language more approachable for beginners without sacrificing safety Better IDE support and debugging tools Expanding the standard library while maintaining stability guarantees Conclusion: The Inevitable Rise Rust’s rise isn’t just another programming language trend—it’s a fundamental shift in how we approach systems programming. By solving the decades-old trilemma of speed, safety, and ergonomics, Rust has positioned itself as the natural successor to C and C++ for new projects.\nLooking at the data from 2024/2025, one thing becomes crystal clear: we’re witnessing Rust’s transition from “promising systems language” to “essential enterprise technology”. The 68.75% surge in commercial adoption isn’t just growth—it’s validation of a fundamental shift in how the industry thinks about systems programming.\nThe convergence of WebAssembly maturity, game engine development with Bevy, widespread enterprise adoption, and a thriving open-source ecosystem has created unstoppable momentum. Companies that were once skeptical are now racing to build Rust expertise, recognizing that this isn’t just about following a trend—it’s about building software that’s demonstrably safer, faster, and more reliable.\nFor developers, the message is clear: Rust is no longer optional if you want to work on cutting-edge systems. For organizations, the question isn’t whether to adopt Rust, but how quickly they can build the expertise to leverage it effectively.\nThe elevator that got stuck and frustrated Graydon Hoare in 2010 has led to a language that’s unsticking software development from decades of accepting that crashes, vulnerabilities, and memory leaks were inevitable. Rust proves they’re not—they’re a choice. And increasingly, it’s a choice that forward-thinking organizations are refusing to make.\nThe rise of Rust isn’t just continuing—it’s accelerating. And we’re still in the early chapters of this transformation. If this is what Rust adoption looks like when the language is still evolving, imagine the landscape in 2030. The best time to start with Rust was five years ago. The second-best time is now.\n","wordCount":"2468","inLanguage":"en","image":"http://localhost:1313/riseofrust.png","datePublished":"2025-09-18T12:53:54+05:30","dateModified":"2025-09-18T12:53:54+05:30","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/rise-and-rise-of-rust/"},"publisher":{"@type":"Organization","name":"Svādhyāya","logo":{"@type":"ImageObject","url":"http://localhost:1313/icon-1.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Svādhyāya (Alt + H)"><img src=http://localhost:1313/icon-1.png alt aria-label=logo height=35>Svādhyāya</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Rise and Rise of Rust</h1><div class=post-meta><span title='2025-09-18 12:53:54 +0530 IST'>September 18, 2025</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;2468 words</div></header><div class=post-content><h2 id=the-quiet-beginning-and-the-first-ripples>The Quiet Beginning and the First Ripples<a hidden class=anchor aria-hidden=true href=#the-quiet-beginning-and-the-first-ripples>#</a></h2><p>In 2010, a Mozilla researcher named Graydon Hoare began working on a personal project born from frustration—a stuck elevator had triggered a software failure that could have been prevented with better memory management. This moment of annoyance would eventually give birth to Rust, a language that would fundamentally challenge how we think about systems programming.</p><p>For its first few years, Rust remained largely within Mozilla&rsquo;s walls, quietly evolving through rapid iterations. The language reached its 1.0 stable release in May 2015, marking the beginning of its public journey. But it wasn&rsquo;t until 2017-2018 that the first significant impacts began to show. <a href=https://blog.rust-lang.org/2017/11/14/Fearless-Concurrency-In-Firefox-Quantum/>Firefox&rsquo;s Quantum release in 2017, which incorporated Rust components for CSS parsing and rendering</a>, demonstrated that Rust could deliver on its promises at scale—offering both memory safety and performance that matched or exceeded C++.</p><p>The early adopters were pioneers willing to bet on an unproven technology. Dropbox began experimenting with Rust for their file synchronization engine around 2016, while Discord started evaluating it for performance-critical services. These early experiments would soon turn into production success stories that would inspire an entire industry.</p><h2 id=the-enterprise-awakening-when-giants-started-moving>The Enterprise Awakening: When Giants Started Moving<a hidden class=anchor aria-hidden=true href=#the-enterprise-awakening-when-giants-started-moving>#</a></h2><p>By 2019-2020, something remarkable was happening. Major technology companies weren&rsquo;t just experimenting with Rust—they were making strategic commitments to it. Microsoft made headlines when they announced that they were exploring Rust for systems programming in Windows, citing that 70% of their security vulnerabilities were memory safety issues that Rust could eliminate by design.</p><p>Companies like Microsoft, Amazon, Dropbox, Discord, and Cloudflare began migrating critical infrastructure to Rust. The community was growing exponentially, with contributions pouring in from developers worldwide. The Rust Foundation was established in 2021 with founding members including AWS, Google, Microsoft, Mozilla, and Huawei—a clear signal that Rust had graduated from interesting experiment to strategic technology.</p><p>Discord&rsquo;s migration story became legendary in engineering circles. Their &ldquo;Read States&rdquo; service, which tracks which channels and messages users have read and is accessed every time you connect to Discord, every time a message is sent and every time a message is read, was suffering from Go&rsquo;s garbage collection pauses. After switching to Rust, latency, CPU, and memory were all better in the Rust version, with average response times measured in microseconds rather than milliseconds.</p><p>The Linux kernel, the holy grail of systems programming, accepted Rust as its second official language in 2022—a decision that sent shockwaves through the industry. For decades, the kernel had been written entirely in C. This acceptance wasn&rsquo;t just symbolic; it was practical recognition that Rust&rsquo;s safety guarantees could prevent entire classes of vulnerabilities in the world&rsquo;s most critical software infrastructure.</p><h2 id=the-present-age-rust-everywhere>The Present Age: Rust Everywhere<a hidden class=anchor aria-hidden=true href=#the-present-age-rust-everywhere>#</a></h2><p>Fast forward to 2025, and Rust&rsquo;s adoption has reached a tipping point. According to JetBrains&rsquo; State of Developer Ecosystem Survey in 2024, an estimated 2,267,000 developers used Rust in a span of 12 months, with 709,000 identifying Rust as their primary language. This isn&rsquo;t just growth—it&rsquo;s an explosion.</p><p>For the ninth year in a row, the 2024 Stack Overflow Developer Survey named Rust the language that developers admired most, with an 83% admiration rate. But beyond developer satisfaction, the real story is in production deployment. Commercial Rust usage exploded by 68.75% between 2021-2024, with tech giants not just using Rust, but betting their future on it.</p><p>Since adopting Rust for Android, Google has cut memory vulnerabilities from 223 in 2019 to under 50 in 2024—a 68% drop. Amazon&rsquo;s Firecracker, the microVM technology behind AWS Lambda, is written entirely in Rust, handling millions of serverless function invocations. Meta added Rust as an officially supported server-side language alongside C++ and Python.</p><p>The open source ecosystem has flourished beyond anyone&rsquo;s expectations. Cargo, Rust&rsquo;s package manager, hosts over 150,000 crates (packages), covering everything from web frameworks to machine learning libraries. Tools that developers rely on daily are increasingly being rewritten in Rust—from JavaScript bundlers like SWC and Turbopack to terminal emulators like Alacritty and Warp.</p><h3 id=webassembly-rusts-killer-app>WebAssembly: Rust&rsquo;s Killer App<a hidden class=anchor aria-hidden=true href=#webassembly-rusts-killer-app>#</a></h3><p>Perhaps no technology has done more to accelerate Rust adoption than WebAssembly (WASM). Rust has become a first-class language for WebAssembly, enabling high-performance, sandboxed code to run in the browser. Based on comprehensive benchmarks, Rust outperforms C++ in most WebAssembly 3.0 scenarios in 2025, showing 15-20% better performance in numerical computations and 30% faster DOM manipulation.</p><p>Companies are ditching Docker containers in favor of Wasm modules compiled from Rust, finding them to be faster, lighter, and more secure. The startup time for a WASM module is measured in microseconds compared to seconds for containers, and the memory footprint is a fraction of traditional containerized applications.</p><h3 id=bevy-the-game-engine-revolution>Bevy: The Game Engine Revolution<a hidden class=anchor aria-hidden=true href=#bevy-the-game-engine-revolution>#</a></h3><p>In the game development world, Bevy has emerged as Rust&rsquo;s flagship game engine, challenging the dominance of Unity and Unreal. With its Entity Component System (ECS) architecture that scales to millions of entities with zero overhead, Bevy is attracting indie developers and AAA studios alike. The engine&rsquo;s ability to compile to both native code and WebAssembly means games can run at full performance in browsers without plugins—a dream that&rsquo;s finally becoming reality.</p><h2 id=the-secret-sauce-why-rust-succeeds-where-others-failed>The Secret Sauce: Why Rust Succeeds Where Others Failed<a hidden class=anchor aria-hidden=true href=#the-secret-sauce-why-rust-succeeds-where-others-failed>#</a></h2><h3 id=memory-safety-without-compromise>Memory Safety Without Compromise<a hidden class=anchor aria-hidden=true href=#memory-safety-without-compromise>#</a></h3><p>Rust&rsquo;s ownership system is revolutionary because it achieves memory safety without garbage collection. The system provides more predictable performance characteristics as there are no pauses for garbage collection. This isn&rsquo;t just about preventing crashes—it&rsquo;s about eliminating entire categories of security vulnerabilities at compile time.</p><p>Microsoft&rsquo;s Security Report shows that Rust eliminates 70% of memory-related bugs, which traditionally account for the majority of critical security vulnerabilities. When you compile a Rust program successfully, you have mathematical guarantees about memory safety that no amount of testing in C++ could provide.</p><h3 id=performance-that-matches-c>Performance That Matches C++<a hidden class=anchor aria-hidden=true href=#performance-that-matches-c>#</a></h3><p>Benchmarks consistently show Rust matching or exceeding C++ performance. Rust&rsquo;s performance cannot be overstated. Benchmarks consistently show Rust matching or surpassing C and C++ in execution speed, while still offering concurrency support that avoids common pitfalls. The zero-cost abstractions mean you can write high-level, expressive code that compiles down to the same machine code as hand-optimized C.</p><h3 id=developer-experience-that-doesnt-suck>Developer Experience That Doesn&rsquo;t Suck<a hidden class=anchor aria-hidden=true href=#developer-experience-that-doesnt-suck>#</a></h3><p>Unlike C++, which has accumulated decades of complexity and gotchas, Rust was designed from the ground up with developer experience in mind. Cargo handles dependencies, building, testing, and documentation generation. The compiler&rsquo;s error messages are so helpful they&rsquo;ve become legendary—often suggesting exact fixes for problems. The standard library is comprehensive and modern, and the documentation is exceptional.</p><h3 id=fearless-concurrency>Fearless Concurrency<a hidden class=anchor aria-hidden=true href=#fearless-concurrency>#</a></h3><p>Rust&rsquo;s relatively unique memory management approach incorporates the idea of memory &ldquo;ownership&rdquo;. It knows when the program is using memory and immediately frees the memory once it is no longer needed. This ownership system makes data races impossible at compile time. You can write concurrent code with confidence, knowing that if it compiles, it&rsquo;s free from data races.</p><h2 id=adopting-rust-lessons-from-the-trenches>Adopting Rust: Lessons from the Trenches<a hidden class=anchor aria-hidden=true href=#adopting-rust-lessons-from-the-trenches>#</a></h2><h3 id=discords-playbook-incremental-migration>Discord&rsquo;s Playbook: Incremental Migration<a hidden class=anchor aria-hidden=true href=#discords-playbook-incremental-migration>#</a></h3><p>Discord&rsquo;s approach to Rust adoption has become a template for others. They started by rewriting a single service—the Read States service—which was experiencing performance issues with Go&rsquo;s garbage collector. The results were so impressive that they&rsquo;ve continued migrating services to Rust, including their database migration tooling, where they wrote it from scratch in Rust because using existing tools would have taken 3 months, but with Rust and the Tokio async ecosystem, migration was completed in just 9 days.</p><h3 id=dropboxs-testament-betting-big-and-winning>Dropbox&rsquo;s Testament: Betting Big and Winning<a hidden class=anchor aria-hidden=true href=#dropboxs-testament-betting-big-and-winning>#</a></h3><p>Dropbox rewrote their sync engine, codenamed &ldquo;Nucleus,&rdquo; entirely in Rust. They stated that &ldquo;Rust has been a force multiplier for our team, and betting on Rust was one of the best decisions we made&rdquo;. The new engine handles billions of files and trillions of synchronizations with improved performance and reliability.</p><h3 id=microsofts-strategy-gradual-system-integration>Microsoft&rsquo;s Strategy: Gradual System Integration<a hidden class=anchor aria-hidden=true href=#microsofts-strategy-gradual-system-integration>#</a></h3><p>Microsoft has been methodically introducing Rust into Windows components, Azure infrastructure, and developer tools. They&rsquo;re not doing a wholesale rewrite but strategically replacing components where memory safety is critical. This measured approach has allowed them to gain experience and build internal expertise while managing risk.</p><h3 id=amazons-cloud-revolution>Amazon&rsquo;s Cloud Revolution<a hidden class=anchor aria-hidden=true href=#amazons-cloud-revolution>#</a></h3><p>AWS has gone all-in on Rust for new services. Beyond Firecracker, they&rsquo;re using Rust for Bottlerocket (their container OS), parts of S3, and various internal tools. AWS cites performance, security, and resource efficiency as key reasons for choosing Rust over C++.</p><h2 id=the-challenges-lets-be-honest>The Challenges: Let&rsquo;s Be Honest<a hidden class=anchor aria-hidden=true href=#the-challenges-lets-be-honest>#</a></h2><h3 id=the-learning-curve-is-real>The Learning Curve Is Real<a hidden class=anchor aria-hidden=true href=#the-learning-curve-is-real>#</a></h3><p>Learning curve: 5-6 months to proficiency, steepest in first 1-2 months. The ownership system, lifetimes, and borrow checker require a fundamentally different way of thinking about code. One of the main challenges of learning Rust is grappling with its borrow checker—a mechanism that ensures references do not outlive the data they refer to.</p><p>Companies report that onboarding engineers to Rust typically takes 3-6 months, compared to weeks for languages like Go or Python. However, once over the hump, developers report higher productivity and confidence in their code.</p><h3 id=compilation-times>Compilation Times<a hidden class=anchor aria-hidden=true href=#compilation-times>#</a></h3><p>Rust&rsquo;s comprehensive compile-time checks come at a cost. Large projects can take several minutes to compile from scratch, though incremental compilation has improved significantly. Teams often need to invest in better CI/CD infrastructure and adopt strategies like compilation caching.</p><h3 id=ecosystem-gaps>Ecosystem Gaps<a hidden class=anchor aria-hidden=true href=#ecosystem-gaps>#</a></h3><p>While Rust&rsquo;s ecosystem is growing rapidly, it still lacks the maturity of languages like Java or Python in certain domains. GUI frameworks are still evolving, and some specialized libraries common in other languages don&rsquo;t yet have Rust equivalents.</p><h3 id=talent-scarcity>Talent Scarcity<a hidden class=anchor aria-hidden=true href=#talent-scarcity>#</a></h3><p>Rust developers command salary premiums of 15-20% over comparable roles in other languages. The demand far exceeds supply, making it challenging and expensive to build Rust teams quickly.</p><h2 id=validation-through-real-world-use-cases>Validation Through Real-World Use Cases<a hidden class=anchor aria-hidden=true href=#validation-through-real-world-use-cases>#</a></h2><h3 id=where-rust-shines-brightest>Where Rust Shines Brightest<a hidden class=anchor aria-hidden=true href=#where-rust-shines-brightest>#</a></h3><p><strong>Systems Programming</strong>: Major tech companies like Microsoft, Google, Amazon, and Meta are increasingly using Rust for critical systems components. This includes operating system development (with Rust now in the Linux kernel), browser development, and low-level Windows components.</p><p><strong>Cloud Infrastructure</strong>: Cloudflare has rewritten significant portions of their edge computing platform in Rust, handling millions of requests per second with improved reliability and lower resource consumption.</p><p><strong>Blockchain</strong>: Solana, Polkadot, and NEAR Protocol are all built primarily in Rust. The combination of performance, safety, and deterministic execution makes Rust ideal for blockchain implementations.</p><p><strong>Embedded Systems</strong>: There&rsquo;s a slight uptick in users targeting embedded platforms, where Rust&rsquo;s safety and performance are highly valued. The ability to write safe code without a runtime or garbage collector is perfect for resource-constrained environments.</p><p><strong>Web Services</strong>: Companies like 1Password, Figma, and npm have significant Rust components in their backend services, citing improved performance and reduced operational costs.</p><h3 id=when-to-choose-rust>When to Choose Rust<a hidden class=anchor aria-hidden=true href=#when-to-choose-rust>#</a></h3><p>Choose Rust when:</p><ul><li>Memory safety and security are critical</li><li>Performance requirements approach hardware limits</li><li>You&rsquo;re building infrastructure that will run for years</li><li>Concurrent processing is a core requirement</li><li>You need predictable latency (no GC pauses)</li><li>The cost of bugs is high (financial systems, medical devices)</li></ul><p>Consider alternatives when:</p><ul><li>Rapid prototyping is more important than performance</li><li>You need to hire many developers quickly</li><li>The existing ecosystem in another language is critical</li><li>The application is primarily I/O bound rather than CPU bound</li></ul><h2 id=the-future-where-rust-goes-from-here>The Future: Where Rust Goes from Here<a hidden class=anchor aria-hidden=true href=#the-future-where-rust-goes-from-here>#</a></h2><h3 id=the-2026-2030-trajectory>The 2026-2030 Trajectory<a hidden class=anchor aria-hidden=true href=#the-2026-2030-trajectory>#</a></h3><p>As we approach 2026, we can expect Rust to further penetrate industries that rely on performance, security, and reliability—like finance, automotive, aerospace, and healthcare. Several trends are converging to accelerate Rust adoption:</p><p><strong>AI and Machine Learning</strong>: While Python dominates AI research, Rust is becoming the language of choice for production inference engines. Teams prototype in Python, then deploy with Rust. Libraries like Candle and Burn are making Rust-native ML more accessible.</p><p><strong>Edge Computing</strong>: As computing moves to the edge, Rust&rsquo;s small binaries and predictable performance become even more valuable. The combination of Rust and WebAssembly is enabling new architectures where code can run anywhere from cloud to browser to IoT devices.</p><p><strong>Automotive and Aerospace</strong>: Industries with strict safety requirements are embracing Rust. Several automotive companies are using Rust for next-generation vehicle software, where failures could be catastrophic.</p><p><strong>Financial Services</strong>: High-frequency trading firms and cryptocurrency platforms are increasingly turning to Rust for its combination of performance and correctness guarantees.</p><h3 id=the-ecosystem-evolution>The Ecosystem Evolution<a hidden class=anchor aria-hidden=true href=#the-ecosystem-evolution>#</a></h3><p>The Rust ecosystem is approaching an inflection point. With the async ecosystem maturing, GUI frameworks stabilizing, and tooling improving, many of the historical barriers to adoption are falling away.</p><p>WASM is a game changer and the merging of Rust and WASM will be seamless. Developers will now be able to create web applications that are high performance and directly run on browsers, pushing the limits of web development.</p><p>Game development in Rust is accelerating, with engines like Bevy gaining traction and major studios beginning to adopt Rust for performance-critical components. The ability to share code between server and client through WASM is opening new architectural possibilities.</p><h3 id=the-language-evolution>The Language Evolution<a hidden class=anchor aria-hidden=true href=#the-language-evolution>#</a></h3><p>The Rust team&rsquo;s focus has shifted from adding features to improving ergonomics and reducing friction. 2025 Focus: Rust&rsquo;s H1 2025 efforts prioritized stabilizing compiler flags and tooling rather than launching new language features—a maturity-oriented shift that enterprises wanted to see.</p><p>Future improvements will focus on:</p><ul><li>Reducing compilation times through better incremental compilation</li><li>Improving the async experience with better syntax and error messages</li><li>Making the language more approachable for beginners without sacrificing safety</li><li>Better IDE support and debugging tools</li><li>Expanding the standard library while maintaining stability guarantees</li></ul><h2 id=conclusion-the-inevitable-rise>Conclusion: The Inevitable Rise<a hidden class=anchor aria-hidden=true href=#conclusion-the-inevitable-rise>#</a></h2><p>Rust&rsquo;s rise isn&rsquo;t just another programming language trend—it&rsquo;s a fundamental shift in how we approach systems programming. By solving the decades-old trilemma of speed, safety, and ergonomics, Rust has positioned itself as the natural successor to C and C++ for new projects.</p><p>Looking at the data from 2024/2025, one thing becomes crystal clear: we&rsquo;re witnessing Rust&rsquo;s transition from &ldquo;promising systems language&rdquo; to &ldquo;essential enterprise technology&rdquo;. The 68.75% surge in commercial adoption isn&rsquo;t just growth—it&rsquo;s validation of a fundamental shift in how the industry thinks about systems programming.</p><p>The convergence of WebAssembly maturity, game engine development with Bevy, widespread enterprise adoption, and a thriving open-source ecosystem has created unstoppable momentum. Companies that were once skeptical are now racing to build Rust expertise, recognizing that this isn&rsquo;t just about following a trend—it&rsquo;s about building software that&rsquo;s demonstrably safer, faster, and more reliable.</p><p>For developers, the message is clear: Rust is no longer optional if you want to work on cutting-edge systems. For organizations, the question isn&rsquo;t whether to adopt Rust, but how quickly they can build the expertise to leverage it effectively.</p><p>The elevator that got stuck and frustrated Graydon Hoare in 2010 has led to a language that&rsquo;s unsticking software development from decades of accepting that crashes, vulnerabilities, and memory leaks were inevitable. Rust proves they&rsquo;re not—they&rsquo;re a choice. And increasingly, it&rsquo;s a choice that forward-thinking organizations are refusing to make.</p><p>The rise of Rust isn&rsquo;t just continuing—it&rsquo;s accelerating. And we&rsquo;re still in the early chapters of this transformation. If this is what Rust adoption looks like when the language is still evolving, imagine the landscape in 2030. The best time to start with Rust was five years ago. The second-best time is now.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=http://localhost:1313/posts/database-design/><span class=title>Next »</span><br><span>Database Design for Products</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Rise and Rise of Rust on x" href="https://x.com/intent/tweet/?text=Rise%20and%20Rise%20of%20Rust&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2frise-and-rise-of-rust%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Rise and Rise of Rust on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2frise-and-rise-of-rust%2f&amp;title=Rise%20and%20Rise%20of%20Rust&amp;summary=Rise%20and%20Rise%20of%20Rust&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2frise-and-rise-of-rust%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Rise and Rise of Rust on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2frise-and-rise-of-rust%2f&title=Rise%20and%20Rise%20of%20Rust"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Rise and Rise of Rust on whatsapp" href="https://api.whatsapp.com/send?text=Rise%20and%20Rise%20of%20Rust%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2frise-and-rise-of-rust%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Rise and Rise of Rust on ycombinator" href="https://news.ycombinator.com/submitlink?t=Rise%20and%20Rise%20of%20Rust&u=http%3a%2f%2flocalhost%3a1313%2fposts%2frise-and-rise-of-rust%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://souravbasu-xyz.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><div><span style=margin-right:.5rem;font-size:1.25em ;>Made with ❤️ in 🇮🇳 !</span></div><span>&copy; 2025 <a href=http://localhost:1313/>Svādhyāya</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>